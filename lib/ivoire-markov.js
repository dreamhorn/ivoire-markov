// Generated by CoffeeScript 1.9.3
(function() {
  "use strict";
  var END, Generator, Ivoire, START, _, init_trail;

  _ = require("lodash");

  Ivoire = require('ivoire-weighted-choice');

  START = "START";

  END = "END";

  init_trail = function(length) {
    var trail;
    trail = [];
    while (trail.length < length) {
      trail.push(START);
    }
    return trail;
  };

  Ivoire.train_markov_chain = function(corpus, lookback) {
    var dive, i, item, j, k, len, len1, len2, letter, lookback_distance, matrix, new_segment, part, raw_item, result, segment, trail;
    if (lookback === void 0) {
      lookback = 1;
    }
    lookback_distance = lookback + 1;
    Ivoire.panic_if(corpus.length <= 0, "The provided corpus must contain data!");
    Ivoire.panic_if(lookback_distance <= 0, "The lookback distance must be greater than 0!");
    Ivoire.panic_if(Math.floor(lookback_distance) !== lookback_distance, "The lookback distance must be an integer!");
    matrix = {
      sum: 0,
      children: {}
    };
    for (i = 0, len = corpus.length; i < len; i++) {
      raw_item = corpus[i];
      trail = init_trail(lookback_distance);
      item = raw_item.split("");
      item.push(END);
      for (j = 0, len1 = item.length; j < len1; j++) {
        letter = item[j];
        trail.push(letter);
        while (trail.length > lookback_distance) {
          trail = trail.splice(1);
        }
        matrix.sum += 1;
        dive = matrix;
        for (k = 0, len2 = trail.length; k < len2; k++) {
          part = trail[k];
          if (!dive.children) {
            dive.children = {};
          }
          if (!dive.children.hasOwnProperty(part)) {
            new_segment = {
              sum: 1
            };
            dive.children[part] = new_segment;
            dive = new_segment;
          } else {
            segment = dive.children[part];
            segment.sum += 1;
            dive = segment;
          }
        }
      }
    }
    result = {
      matrix: matrix,
      lookback: lookback_distance
    };
    return result;
  };

  Ivoire.prototype.get_markov_generator = function(options) {
    return new Generator(this, options);
  };

  Generator = (function() {
    function Generator(rng, arg) {
      this.rng = rng;
      this.matrix = arg.matrix, this.lookback = arg.lookback;
    }

    Generator.prototype.generate = function(max_length) {
      var choice, dive, graceful, selections, sums, trail, values;
      trail = init_trail(this.lookback);
      selections = [];
      graceful = false;
      while (selections.length < max_length || !max_length) {
        while (trail.length > this.lookback - 1) {
          trail = trail.splice(1);
        }
        dive = this.matrix;
        _.each(trail, function(part) {
          return dive = dive.children[part];
        });
        values = [];
        sums = [];
        _.each(dive.children, function(value, key) {
          values.push(key);
          return sums.push(value.sum);
        });
        choice = this.rng.weighted_choice(values, sums);
        if (choice === END) {
          graceful = true;
          break;
        } else {
          selections.push(choice);
          trail.push(choice);
        }
      }
      return selections.join("");
    };

    return Generator;

  })();

  module.exports = Ivoire;

}).call(this);
